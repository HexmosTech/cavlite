#!/bin/bash

VERSION="0.0.5"

# Enforce Sudo
if [ "$EUID" -ne 0 ]; then
    echo "‚ùå Error: This script must be run as root."
    exit 1
fi

# Setup
# --- CONFIGURATION START ---
# Default values
WEBHOOK_URL=""
SERVER_NAME=$(hostname -s)

# Load configuration
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# 1. Load local config (Development)
if [ -f "$SCRIPT_DIR/config/cavlite.conf" ]; then
    source "$SCRIPT_DIR/config/cavlite.conf"
fi

# 2. Load system config (Production - Overrides local)
if [ -f "/etc/cavlite/cavlite.conf" ]; then
    source "/etc/cavlite/cavlite.conf"
fi

# Set defaults if not provided in config
: "${SCAN_PATH:=/}"
: "${QUARANTINE_DIR:=/var/quarantine}"


# Paths
LOG_DIR="/var/log"
LOG_FILE="$LOG_DIR/security_audit.log"
PID_FILE="/var/run/security_audit.pid"
CLEANER_SCRIPT="/usr/local/lib/cavlite/filter"
CLAMD_CONF="/etc/clamav/clamd.conf"
# --- CONFIGURATION END ---

function cleanup_clamd_config() {
    if [ -f "$CLAMD_CONF" ]; then
        # Check if our block exists
        if grep -q "### CAVlite Start" "$CLAMD_CONF"; then
            echo "üßπ Cleaning up cavlite configuration from $CLAMD_CONF..." | tee -a "$LOG_FILE"
            # Remove the block from Start to End
            sed -i '/### CAVlite Start/,/### CAVlite END/d' "$CLAMD_CONF"
            
            # Restart daemon to apply cleanup
            systemctl stop clamav-daemon.socket 2>/dev/null
            systemctl restart clamav-daemon
        fi
    fi
}

function update_clamd_config() {
    cleanup_clamd_config # Ensure clean slate

    if [ -n "${EXCLUDE_PATHS+x}" ]; then
        echo "‚öôÔ∏è Injecting exclusions into $CLAMD_CONF..." | tee -a "$LOG_FILE"
        
        {
            echo ""
            echo "### CAVlite Start"
            for path in "${EXCLUDE_PATHS[@]}"; do
                # Escape special characters for regex if necessary, but simple paths are usually safe
                # ExcludePath expects a regex
                echo "ExcludePath ^$path"
            done
            echo "### CAVlite END"
        } >> "$CLAMD_CONF"
        
        # Restart daemon to apply changes
        echo "üîÑ Restarting clamav-daemon to apply configuration..." | tee -a "$LOG_FILE"
        systemctl stop clamav-daemon.socket 2>/dev/null
        systemctl restart clamav-daemon
        
        # Wait for daemon to be ready
         for i in {1..60}; do 
            if systemctl is-active --quiet clamav-daemon; then
                # Give it a few more seconds to actually bind socket
                sleep 5
                break
            fi
            sleep 2
        done
    fi
}

function send_notification() {
    local content="$1"
    local file_to_attach="$2"

    if [ -z "$WEBHOOK_URL" ]; then
        echo "‚ö†Ô∏è  Warning: WEBHOOK_URL is not set. Skipping notification."
        return
    fi

    read -r -d '' PAYLOAD <<EOF
{
  "content": "$(echo -e "$content" | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/"/\\"/g')"
}
EOF

    if [[ -n "$file_to_attach" && -f "$file_to_attach" ]]; then
        curl -s -X POST "$WEBHOOK_URL" -F "payload_json=$PAYLOAD" -F "file=@$file_to_attach"
    else
        curl -s -X POST "$WEBHOOK_URL" -H "Content-Type: application/json" -d "$PAYLOAD"
    fi
}

function check_discord() {
    echo "üîç Checking Discord Webhook configuration..."
    if [ -z "$WEBHOOK_URL" ]; then
        echo "‚ùå Error: WEBHOOK_URL is not configured in /etc/cavlite/cavlite.conf"
        exit 1
    fi

    echo "üì® Sending test notification..."
    send_notification "‚úÖ **Test Notification**: cavlite webhook is working correctly on $SERVER_NAME."
    echo "‚úÖ Test notification sent. Please check your Discord channel."
}

function start_scan() {
    if [ -f "$PID_FILE" ]; then
        echo "Scan is already in progress (PID: $(cat $PID_FILE)). Exiting."
        exit 1
    fi

    # Create log directory
    mkdir -p "$LOG_DIR"
    # Rotate previous log
    [ -f "$LOG_FILE" ] && mv "$LOG_FILE" "${LOG_FILE}.old"

    echo $$ >"$PID_FILE"
    trap 'cleanup_clamd_config; rm -f "$PID_FILE"; systemctl stop clamav-daemon &>/dev/null' EXIT

    # Start logging
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    echo "üîê Security Audit Started - $TIMESTAMP on $SERVER_NAME" | tee "$LOG_FILE"
    echo "üìÇ Scanning Path: $SCAN_PATH" | tee -a "$LOG_FILE"
    if [ -n "${EXCLUDE_PATHS+x}" ]; then
        echo "üö´ Excluded Paths (Configured in $CLAMD_CONF): ${EXCLUDE_PATHS[*]}" | tee -a "$LOG_FILE"
    fi

    # Inject configuration
    update_clamd_config



    echo "Running ClamAV scan on $SERVER_NAME..." >> "$LOG_FILE"
    
    # Count files to scan (for reporting confidence)
    echo "üîç Calculating files to scan..." | tee -a "$LOG_FILE"
    FIND_OPTS=()
    if [ -n "${EXCLUDE_PATHS+x}" ]; then
        for path in "${EXCLUDE_PATHS[@]}"; do
            FIND_OPTS+=("-path" "$path" "-prune" "-o")
        done
    fi
    FILE_COUNT=$(find "$SCAN_PATH" "${FIND_OPTS[@]}" -type f -print | wc -l)
    echo "üìÑ Found $FILE_COUNT files to scan." | tee -a "$LOG_FILE"

    mkdir -p "$QUARANTINE_DIR"
    
    # --- TARGET FOLDER IS SET HERE ---
    # Run clamdscan directly on the path. The daemon handles exclusions via config.
    clamdscan --multiscan --fdpass "$SCAN_PATH" --move="$QUARANTINE_DIR" 2>&1 | tee -a "$LOG_FILE"
    CLAM_EXIT=${PIPESTATUS[0]}

    echo -e "\nRunning Lynis audit..." >> "$LOG_FILE"
    lynis audit system >> "$LOG_FILE"
    LYNIS_EXIT=${PIPESTATUS[0]}

    echo -e "\nCleaning up log file..." >> "$LOG_FILE"
    CLEANED_LOG_FILE=$(python3 "$CLEANER_SCRIPT" "$LOG_FILE")

    if [[ -n "$CLEANED_LOG_FILE" && -f "$CLEANED_LOG_FILE" ]]; then
        CLEANED_CONTENT=$(cat "$CLEANED_LOG_FILE")
    else
        if [[ $CLAM_EXIT -eq 0 && $LYNIS_EXIT -eq 0 ]]; then
            CLEANED_CONTENT="‚úÖ Security audit completed successfully on $SERVER_NAME."
        else
            CLEANED_CONTENT="‚ö†Ô∏è Security audit completed with issues on $SERVER_NAME."
        fi
    fi
    
    # Cleanup config immediately after scan
    cleanup_clamd_config

    # Send the main notification
    send_notification "$CLEANED_CONTENT" "$LOG_FILE"

    # --- MARKER: THIS PREVENTS DOUBLE NOTIFICATIONS ---
    echo "### SCAN_FINISHED_NOTIFICATION_SENT ###" >> "$LOG_FILE"

    echo "Stopping clamav-daemon..." >> "$LOG_FILE"
    systemctl stop clamav-daemon
    
    echo "‚úÖ Scan completed. Logs available at $LOG_FILE"
}

function stop_scan() {
    # Ensure config is cleaned up even on stop
    cleanup_clamd_config

    # --- UPDATED LOGIC TO PREVENT DOUBLE NOTIFICATION ---
    # 1. Check if the SUCCESS notification marker exists
    # 2. OR Check if we are in the cleaning up phase
    if [ -f "$LOG_FILE" ]; then
        if grep -q "### SCAN_FINISHED_NOTIFICATION_SENT ###" "$LOG_FILE"; then
            echo "Scan finished and notification was already sent. Stopping silently..."
            SILENT_STOP=true
        elif grep -q "Cleaning up log file..." "$LOG_FILE"; then
            # If it's cleaning up but hasn't sent the notification yet, we might want to wait,
            # but to be safe let's treat it as 'almost done' and kill silently to avoid spam.
            echo "Scan is in final cleanup phase. Stopping silently..."
            SILENT_STOP=true
        else
            SILENT_STOP=false
        fi
    else
        SILENT_STOP=false
    fi

    if [ "$SILENT_STOP" = true ]; then
        systemctl stop clamav-daemon.socket 2>/dev/null
        systemctl stop clamav-daemon 2>/dev/null
        pkill -9 clamdscan 2>/dev/null
        pkill -9 clamd 2>/dev/null
        pkill -9 lynis 2>/dev/null
        if [ -f "$PID_FILE" ]; then
            kill "$(cat "$PID_FILE")" 2>/dev/null
            rm -f "$PID_FILE"
        fi
        exit 0
    fi
    # ----------------------------------------

    echo "Stopping security scan..."

    # 1. STOP SYSTEMD SERVICES FIRST (Prevent restart loop)
    # Important: Stop the socket too, otherwise it can auto-activate the service
    echo "Stopping clamav-daemon service and socket..."
    systemctl stop clamav-daemon.socket
    systemctl stop clamav-daemon

    # 2. KILL CLAMSCAN / CLAMDSCAN
    if pgrep "clamdscan" > /dev/null; then
        echo "Found running clamdscan process. Killing it..."
        pkill -9 clamdscan
    fi
    
    # 3. KILL CLAMD (Daemon may be stuck)
    if pgrep "clamd" > /dev/null; then
        echo "Found running clamd process. Killing it..."
        pkill -9 clamd
    fi

    # 4. KILL LYNIS
    if pgrep "lynis" > /dev/null; then
        echo "Found running Lynis process. Killing it..."
        pkill -9 lynis
    fi

    # 3. Stop the daemon
    if systemctl is-active --quiet clamav-daemon; then
        echo "Stopping clamav-daemon..."
        systemctl stop clamav-daemon
    fi

    # 4. Kill the script PID
    if [ -f "$PID_FILE" ]; then
        SCAN_PID=$(cat "$PID_FILE")
        if ps -p "$SCAN_PID" >/dev/null; then
            echo "Terminating script manager (PID: $SCAN_PID)..."
            kill "$SCAN_PID"
        fi
        rm -f "$PID_FILE"
    fi
    
    # 5. Send Interrupted Notification
    echo "Waiting for logs to finalize..."
    sleep 3

    if [ -f "$LOG_FILE" ]; then
        # Double check marker one last time in case it finished inside the 3 second sleep
        if grep -q "### SCAN_FINISHED_NOTIFICATION_SENT ###" "$LOG_FILE"; then
            echo "Scan finished during stop process. Skipping interruption alert."
            exit 0
        fi

        echo "Processing partial log file..."
        echo -e "\n\n--- SCAN INTERRUPTED MANUALLY ---" >> "$LOG_FILE"

        CLEANED_LOG_FILE=$(python3 "$CLEANER_SCRIPT" "$LOG_FILE")

        if [[ -n "$CLEANED_LOG_FILE" && -f "$CLEANED_LOG_FILE" ]]; then
            CLEANED_CONTENT=$(cat "$CLEANED_LOG_FILE")
            NOTIFICATION_MSG="üü° **Scan Interrupted on $SERVER_NAME**\nThe security scan did not complete. Here is a summary of the partial results:\n\n$CLEANED_CONTENT"
            send_notification "$NOTIFICATION_MSG" "$LOG_FILE"
        else
            send_notification "üü° **Scan Interrupted on $SERVER_NAME**\nThe security scan was stopped, but no summary could be generated." "$LOG_FILE"
        fi
    else
        send_notification "üü° **Scan Interrupted on $SERVER_NAME**\nThe security scan was stopped, but no log file was found to process."
    fi

    echo "Scan stopped."
}

function show_help() {
    echo "Usage: $0 {--start|--stop|--check-discord|--help|-h}"
    echo "  --start          Start the security scan (ClamAV and Lynis)."
    echo "  --stop           Stop any running security scan."
    echo "  --check-discord  Test Discord webhook configuration."
    echo "  --help, -h       Display this help message."
}

case "$1" in
--start)
    start_scan
    ;;
--stop)
    stop_scan
    ;;
--check-discord)
    check_discord
    ;;
--help|-h)
    show_help
    ;;
*)
    show_help
    exit 1
    ;;
esac